{"componentChunkName":"component---src-templates-post-template-tsx","path":"/CI_Part4_Ch15/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%9E%99-%EC%97%B0%EC%82%B0\">힙 연산</a></p>\n<ul>\n<li><a href=\"#%EC%82%BD%EC%9E%85\">삽입</a></li>\n<li><a href=\"#%EC%B6%94%EC%B6%9C\">추출</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A7%84-%ED%9E%99-vs-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-bst\">이진 힙 vs 이진 탐색 트리 (BST)</a></p>\n</li>\n<li>\n<p><a href=\"#55-%EB%B0%B0%EC%97%B4%EC%9D%98-k%EB%B2%88%EC%A8%B0-%ED%81%B0-%EC%9A%94%EC%86%8C\">55. 배열의 K번쨰 큰 요소</a></p>\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4-1-heapq-%EB%AA%A8%EB%93%88-%EC%9D%B4%EC%9A%A9\">풀이 1. heapq 모듈 이용</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-2-heapq-%EB%AA%A8%EB%93%88%EC%9D%98-heapify-%EC%9D%B4%EC%9A%A9\">풀이 2. heapq 모듈의 heapify 이용</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-3-heapq-%EB%AA%A8%EB%93%88%EC%9D%98-nlargest-%EC%9D%B4%EC%9A%A9\">풀이 3. heapq 모듈의 nlargest 이용</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-4-%EC%A0%95%EB%A0%AC%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\">풀이 4. 정렬을 이용한 풀이</a></li>\n</ul>\n</li>\n</ul>","html":"<blockquote>\n<p>힙은 힙의 특성(최소 힙에서는 부모가 항상 자식보다 작거나 같다) 을 만족하는 거의 완전한 트리(Almost Complete Tree) 인 특수한 트리 기반의 자료구조</p>\n</blockquote>\n<p>힙은 그래프와 트리와는 전혀 관계 없어 보이는 독특한 이름과 달리, <code class=\"language-text\">트리 기반의 자료구조</code>다. 최소 힙은 부모가 자식보다 작기 때문에 루트가 결국 가장 작은 값을 갖게 되며, 우선순위 큐에서 가장 작은 값을 추출하는 것은 <code class=\"language-text\">매번 힙의 루트를 가져오는 형태</code>로 구현된다.<br>\n우선순위 큐 ADT(추상 자료형)은 주로 힙으로 구현되고, 힙은 주로 배열로 구현한다.<br>\n따라서, 우선순위 큐는 결국 배열로 구현하는 셈이 된다.<br>\n오해하기 쉬운 특징 중 하나는 <code class=\"language-text\">힙은 정렬된 구조가 아니라는 점</code> 이다. 최소 힙의 경우 <code class=\"language-text\">부모 노드가 항상 작다는 조건만 만족</code> 할 뿐, 서로 정렬되어 있지는 않다.<br>\n부모, 자식간의 관계만 정의할 뿐, 좌우에 대한 관계는 정의하지 않기 때문이다. 즉, 부모는 항상 자식보다 작을 뿐, 좌우의 정렬 관계는 제각각이다.<br>\n힙은 <code class=\"language-text\">완전 이진 트리</code> 이기 때문에, 배열로 구현할 수 있다.<br>\n힙으로 <code class=\"language-text\">우선순위 큐</code> 뿐만 아니라 <code class=\"language-text\">다익스트라 알고리즘</code> 에도 활용이 된다. 힙 덕분에 다익스트라 알고리즘의 시간 복잡도는 O(V^2) 에서 <code class=\"language-text\">O(ElogV)</code> 가 된다.<br>\n이외에도 원래의 용도인 힙 정렬과 최소 신장 트리를 구현하는 <code class=\"language-text\">프림 알고리즘</code>등에도 활용되며, 중앙값의 근사값을 빠르게 구하는 데도 활용할 수 있다.</p>\n<h1 id=\"힙-연산\" style=\"position:relative;\">힙 연산<a href=\"#%ED%9E%99-%EC%97%B0%EC%82%B0\" aria-label=\"힙 연산 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>실제로 이진 힙(자식이 둘인 힙)을 구현해보겠다. 파이썬의 <code class=\"language-text\">heapq</code> 모듈에서 지원하는 최소 힙 연산을 파이썬의 리스트만으로 동일하게 구현해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">BinaryHeap</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t\tself<span class=\"token punctuation\">.</span>items <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">]</span>\n\t\n\t<span class=\"token keyword\">def</span> <span class=\"token function\">__len__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span></code></pre></div>\n<p>len()을 호출하면 마지막 요소의 인덱스를 가져오기 위해 실제 길이보다 하나 더 작은 가져오도록 구현했다.<br>\n그리고, 0번 인덱스는 사용하지 않기 때문에, <code class=\"language-text\">None</code>을 넣어두었다. 대게 트리의 배열 표현의 경우 인덱스 계산을 편하게 하기 위해 인덱스는 1부터 사용한다. 특히 이진 힙에서는 항상 1번 인덱스부터 사용한다.</p>\n<h2 id=\"삽입\" style=\"position:relative;\">삽입<a href=\"#%EC%82%BD%EC%9E%85\" aria-label=\"삽입 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>힙에 요소를 삽입하기 위해서는 업힙(Up-Heap) 연산을 수행해야 한다. 업힙 연산은 <code class=\"language-text\">percolate_up()</code> 이라는 함수로 정의한다. 힙에 요소를 삽입하는 과정은 다음과 같다.</p>\n<ol>\n<li>요소를 가장 하위 레벨의 최대한 왼쪽으로 삽입한다.(배열로 표현할 경우 가장 마지막에 삽입된다.)</li>\n<li>부모 값과 비교해 값이 더 작은 경우 위치를 변경한다.</li>\n<li>계속해서 부모 값과 비교해 위치를 변경한다.(가장 작은 값일 경우 루트까지 올라감)</li>\n</ol>\n<p>이 과정을 그림으로 표현하면 다음과 같다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 499px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bb58a005de7678bad60987aa2349e524/f80a3/binary-heap-insert.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.91666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABQ0lEQVQoz3VSa5OCMAzk//8uvyvciBxQ9UShMCJv8AHsTTLSq+hlJtMUks1mGwOajePIPsWT3e93BEGAx+PxkjuvITPmgPrZti2qqmKXUqq4aZq3pm+AnzoKIZAkiUoehgHH4xGe5+F6vf7P8BOY4zh8uq6L8/nMsZQRM73dbrBt++NUhg40fYzjGNvtFofDgQsXiwVWlo0sL17Y6rECnFMmNrvdjkfquo69KAq0XfcH0PdYr9fMdj6d0pC00kHoZYmp3sz3PKxWJmScoKwq9H2Puq5ZFqUhFRCDMAxxSVP1I7tcWLMoihg0TVOOLesL9uYbwzByU5ImPIX8WLRWBq2B8AWDLJdLuOIHaUYNTs+HkMjzHKZpoixLLnScjVorupOR3nQ39vs9ZBTB933uFjwTdOGpiJy0pRwaMcuyt/2lkX8B9RcDTKuPvpMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/bb58a005de7678bad60987aa2349e524/a59e9/binary-heap-insert.webp 192w,\n/static/bb58a005de7678bad60987aa2349e524/0ca9f/binary-heap-insert.webp 384w,\n/static/bb58a005de7678bad60987aa2349e524/aa66f/binary-heap-insert.webp 499w\"\n              sizes=\"(max-width: 499px) 100vw, 499px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/bb58a005de7678bad60987aa2349e524/3b721/binary-heap-insert.png 192w,\n/static/bb58a005de7678bad60987aa2349e524/66595/binary-heap-insert.png 384w,\n/static/bb58a005de7678bad60987aa2349e524/f80a3/binary-heap-insert.png 499w\"\n            sizes=\"(max-width: 499px) 100vw, 499px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/bb58a005de7678bad60987aa2349e524/f80a3/binary-heap-insert.png\"\n            alt=\"이진 힙에서 요소 삽입\"\n            title=\"이진 힙에서 요소 삽입\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n위의 과정을 코드로 구현하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">_percolate_up</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\ti <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span>\n\tparent <span class=\"token operator\">=</span> i <span class=\"token operator\">//</span> <span class=\"token number\">2</span>\n\t<span class=\"token keyword\">while</span> parent <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">:</span>\n\t\t\tself<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\t\ti <span class=\"token operator\">=</span> parent\n\t\tparent <span class=\"token operator\">=</span> i <span class=\"token operator\">//</span> <span class=\"token number\">2</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\tself<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span>\n\tself<span class=\"token punctuation\">.</span>_percolate_up<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>삽입 자체는 insert() 함수를 호출해 실행된다. 코드에서 insert() 함수의 self.items.append()는 1번 과정이고, percolate_up() 함수는 2, 3번 과정을 수행한다.<br>\n시간 복잡도는 <code class=\"language-text\">O(logN)</code> 이다. parent를 i // 2 로 약 절반씩 줄여나가는 형태이므로, 로그만큼 연산을 수행하는 것을 알 수 있다. percolate_up() 함수명 앞에는 <code class=\"language-text\">내부 함수</code> 라는 의미로 <code class=\"language-text\">_</code>를 붙였다.</p>\n<h2 id=\"추출\" style=\"position:relative;\">추출<a href=\"#%EC%B6%94%EC%B6%9C\" aria-label=\"추출 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>추출 자체는 매우 간단하다. <code class=\"language-text\">루트를 추출</code>하면 된다. 추출 이후에 다시 힙의 특성을 유지하는 작업이 필요하기 때문에 시간 복잡도는 O(1)이 아닌 O(logN)이다.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6157146bcec8e680ea5bf0ac7a3b20b4/32ca7/binary-heap-pop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABX0lEQVQoz3WSiY6CQBBE+f/fM2Zdh1PkUkBuBhVqUy3jqpvtBIb0UfO6G2tZACwLoiSHsj30fYc0SVBVFYwtkvR70pqmRhiGeDXGrXl+JLVtKwm32w2XywXjOGIYBpzP5zex0+mELE2x+94jimNorcU3z7PELb66rkOe5/K0TYP7/S4JFIuiSC6g9X0P13URHg4YR72SNlBKoSiKhyCJHMcRR1mWcB1HAiTMsky+SX69XrHZbKSDgwiOEuMFpPc8TzqyKMLCOI7FSTKDTzPfJPV9/3nJ5+yMWZ9BkrAltm/EeLKIozDGcZDO5DC+LuXhqOv6iW8o2QLbe7Xj8Sgzpfg0TdI6yd8Iy6LAfq/wtVOyQRpnxdlxJBQxVJ4fQNn2k4yjYh4f+ixujkthkdYTqnWjFDT/Ion4W223W9iuJ6KT1tJNkiSSw5M1FhNJwS0vy/xnyIaEBUEQIF07+G8pP/ihAmckpG6rAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/6157146bcec8e680ea5bf0ac7a3b20b4/a59e9/binary-heap-pop.webp 192w,\n/static/6157146bcec8e680ea5bf0ac7a3b20b4/0ca9f/binary-heap-pop.webp 384w,\n/static/6157146bcec8e680ea5bf0ac7a3b20b4/d17f0/binary-heap-pop.webp 538w\"\n              sizes=\"(max-width: 538px) 100vw, 538px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/6157146bcec8e680ea5bf0ac7a3b20b4/3b721/binary-heap-pop.png 192w,\n/static/6157146bcec8e680ea5bf0ac7a3b20b4/66595/binary-heap-pop.png 384w,\n/static/6157146bcec8e680ea5bf0ac7a3b20b4/32ca7/binary-heap-pop.png 538w\"\n            sizes=\"(max-width: 538px) 100vw, 538px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/6157146bcec8e680ea5bf0ac7a3b20b4/32ca7/binary-heap-pop.png\"\n            alt=\"이진 힙엥서 오소 추출 과정\"\n            title=\"이진 힙엥서 오소 추출 과정\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n위의 그림은 추출 과정을 보여준다. 루트를 추출하고, 가장 마지막 노드를 루트로 옮긴다. 그리고, 자식 노드와 비교해 자식 노드가 더 작은 경우 위치를 변경한다.<br>\n삽입과는 반대의 연산이므로, <code class=\"language-text\">다운힙</code> 연산이 수행된다. 일반적으로 힙 추출에 많이 쓰이는 <code class=\"language-text\">percolate_down()</code> 이라는 함수로 구현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">_percolate_down</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\tleft <span class=\"token operator\">=</span> idx <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n\tright <span class=\"token operator\">=</span> idx <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\tsmallest <span class=\"token operator\">=</span> idx\n\n\t<span class=\"token keyword\">if</span> left <span class=\"token operator\">&lt;=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>smallest<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">:</span>\n\t\tsmallest <span class=\"token operator\">=</span> left\n\t<span class=\"token keyword\">if</span> right <span class=\"token operator\">&lt;=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>smallest<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">:</span>\n\t\tsmallest <span class=\"token operator\">=</span> right\n\t<span class=\"token keyword\">if</span> smallest <span class=\"token operator\">!=</span> idx <span class=\"token punctuation\">:</span>\n\t\tself<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>smallest<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>smallest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span>\n\t\tself<span class=\"token punctuation\">.</span>_percolate_down<span class=\"token punctuation\">(</span>smallest<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">extract</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\textracted <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\tself<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\tself<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tself<span class=\"token punctuation\">.</span>_percolate_down<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> extracted</code></pre></div>\n<p>추출 자체는 extract() 함수를 호출해 실행된다.</p>\n<h1 id=\"이진-힙-vs-이진-탐색-트리-bst\" style=\"position:relative;\">이진 힙 vs 이진 탐색 트리 (BST)<a href=\"#%EC%9D%B4%EC%A7%84-%ED%9E%99-vs-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-bst\" aria-label=\"이진 힙 vs 이진 탐색 트리 bst permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>가장 직관적인 차이점은, 힙은 <code class=\"language-text\">상/하 관계를 보장</code>하며, 특히 최소 힙에서는 부모가 항상 자식보다 작다. 반면 BST는 <code class=\"language-text\">좌/우 관계를 보장</code>한다. BST에서는 부모는 왼쪽 자식보다는 크며, 오른쪽 자식보다는 작거나 같다. 이 같은 특징으로 인해 BST는 탐색과 삽입 모두 O(logN)에 가능하며, 모든 값이 정렬되어야 할 때 사용한다.<br>\n반면 가장 큰 값을 추출하거나(최대 힙) 가장 작은 값을 추출하려면(최소 힙) 이진 힙을 사용해야 한다. 이진 힙은 이 작업이 O(1) 에 가능하다. 우선순위와 연관되어 있으며, 따라서 이진 힙은 <code class=\"language-text\">우선순위 큐</code>에 활용된다.</p>\n<h1 id=\"55-배열의-k번쨰-큰-요소\" style=\"position:relative;\">55. 배열의 K번쨰 큰 요소<a href=\"#55-%EB%B0%B0%EC%97%B4%EC%9D%98-k%EB%B2%88%EC%A8%B0-%ED%81%B0-%EC%9A%94%EC%86%8C\" aria-label=\"55 배열의 k번쨰 큰 요소 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>정렬되지 않은 배열에서 k번쨰 큰 요소를 추출하라.</p>\n<ul>\n<li>입력</li>\n</ul>\n<p>[3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4</p>\n<ul>\n<li>출력</li>\n</ul>\n<p>4</p>\n<h2 id=\"풀이-1-heapq-모듈-이용\" style=\"position:relative;\">풀이 1. heapq 모듈 이용<a href=\"#%ED%92%80%EC%9D%B4-1-heapq-%EB%AA%A8%EB%93%88-%EC%9D%B4%EC%9A%A9\" aria-label=\"풀이 1 heapq 모듈 이용 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>11장의 31번 문제 “상위 K 빈도 요소” 와 비슷한 문제다. 다른 점이라면 가장 큰 값이냐, 가장 빈번한 값이냐의 차이다. 비슷한 방식으로 풀이가 가능하므로, 그 때 풀이했던 코드를 가져와봤다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">topKFrequent</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\tfreqs <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>Counter<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\n\tfreqs_heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\t<span class=\"token keyword\">for</span> f <span class=\"token keyword\">in</span> freqs <span class=\"token punctuation\">:</span>\n\t\theapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>freqs_heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>freqs<span class=\"token punctuation\">[</span>f<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\ttopk <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t\ttopk<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>freqs_heap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">return</span> topk</code></pre></div>\n<p>Counter()로 빈도 수를 계산해 삽입했던 예전 풀이 대신 값 자체를 힙에 푸시하고 순서만큼 팝하는 형태로 수정해본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\theap <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">for</span> n <span class=\"token keyword\">in</span> nums <span class=\"token punctuation\">:</span>\n\t\theapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>n<span class=\"token punctuation\">)</span>\n\t\n\t<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t\theapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\n\t\n\t<span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span></code></pre></div>\n<p>파이썬 heapq모듈은 <code class=\"language-text\">최소 힙</code>만 지원하므로, 음수로 저장한 다음 가장 낮은 수 부터 추출해 부호를 변환하면 최대 힙 처럼 동작하도록 구현 가능하다.</p>\n<h2 id=\"풀이-2-heapq-모듈의-heapify-이용\" style=\"position:relative;\">풀이 2. heapq 모듈의 heapify 이용<a href=\"#%ED%92%80%EC%9D%B4-2-heapq-%EB%AA%A8%EB%93%88%EC%9D%98-heapify-%EC%9D%B4%EC%9A%A9\" aria-label=\"풀이 2 heapq 모듈의 heapify 이용 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>모든 값을 꺼내서 푸시하지 않고도 한 번에 <code class=\"language-text\">heapify()</code> 하여 처리할 수 있다. heapify()란 주어진 자료구조가 힙 특성을 만족하도록 바꿔주는 연산이며, 이 경우 파이썬의 일반적인 리스트는 힙 특성을 만족하는 리스트로, 값의 위치가 변경된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\theapq<span class=\"token punctuation\">.</span>heapify<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\n\t\n\t<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t\theapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\n\t\n\t<span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"풀이-3-heapq-모듈의-nlargest-이용\" style=\"position:relative;\">풀이 3. heapq 모듈의 nlargest 이용<a href=\"#%ED%92%80%EC%9D%B4-3-heapq-%EB%AA%A8%EB%93%88%EC%9D%98-nlargest-%EC%9D%B4%EC%9A%A9\" aria-label=\"풀이 3 heapq 모듈의 nlargest 이용 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>heapq 모듈은 강력한 기능을 많이 지원한다. 그중에는 n번째 큰 값을 추출하는 <code class=\"language-text\">nlargest()</code> 함수가 있다. 이 함수는 <code class=\"language-text\">n</code>개의 가장 큰 요소를 추출한다. 이 함수를 이용하면 풀이가 매우 간단해진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">return</span> heapq<span class=\"token punctuation\">.</span>nlargest<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>k번째 만큼 큰 값이 가장 큰 값부터 순서대로 리스트로 리턴된다. 마지막 인덱스 -1이 k번째 값이 된다. 힙이 아니라도 내부적으로 heapify() 함수도 호출해 처리해주기 때문에 별도로 힙 처리를 할 필요가 없어 편리하다. 참고로 <code class=\"language-text\">nsmallest()</code> 를 사용하면 동일한 방식으로 n번째 작은 값도 추출이 가능하다.</p>\n<h2 id=\"풀이-4-정렬을-이용한-풀이\" style=\"position:relative;\">풀이 4. 정렬을 이용한 풀이<a href=\"#%ED%92%80%EC%9D%B4-4-%EC%A0%95%EB%A0%AC%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\" aria-label=\"풀이 4 정렬을 이용한 풀이 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이번에는 정렬부터 한 다음, k번째 값을 추출하는 방식으로 풀이해보자. 추가, 삭제가 빈번할 때는 heapq를 이용한 힙 정렬이 유용하지만, 이처럼 <code class=\"language-text\">입력값이 고정되어 있을 때는 그저 한 번 정렬하는 것 만으로 충분</code>하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">findKthLargest</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> reverse<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>4개의 풀이 중, 정렬 방식이 가장 빠르다. 파이썬의 정렬 함수는 <code class=\"language-text\">팀소트(Timsort)</code>를 사용하며 C로 매우 정교하게 구현되어 있기 때문에 대부분의 경우에는 파이썬의 내부 정렬 함수를 사용하는 편이 가장 성능이 좋다.</p>","frontmatter":{"title":"Python Coding Interview - 4부 15장 | 힙","summary":"파이썬 알고리즘 인터뷰 책에서 4부 15장의 내용을 읽고 요약정리","date":"2023.02.12.","categories":["Coding Test","Python"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9ElEQVQoz42SW28SURSF+bfGGOOTL14S64MvNsTEB1AUsG2waLFaoGiaRopt5WKLAxQ6DMO1XK3VamobZg6fYYCBojY+rOyTfXLWWWvvZdHrCiNoQ+gHebRGwTyPYNwP63TfONcVLCbZsGE+KGXQqvtoTRWtXULrlNHTMUR41ahaq3juU23IYzmnsE/aVKGSRSzYEBtBeooEiTA96SOikkOoaXQ5id6vhRR6OXuxwtOqTC22Te/dEmI3wq/cLqfb65ztbHJSynEmRSESQoSD9CJvEcktw8WYcGI2oqFwUswib20Zll7a5/A+dONzevG5XrD8dJ5ns3aiyyvQVulW5b/McKIxUsmXEt/3JeasDr6lojRlmVpeRW/nkOI7+OzzcFimW8v/OcNxo2CSikaBY1liyeHh59caR50Wx/UGHNZp5DMEXB7j027tIoXFDCL2Hj37CdFS+ZFP4bY+pryXoJ5N00xKdBJx4qE1Xj9ZMAlHrnRzyyPCSg49E0cr7Q2XpOB+4OLG5VvcuXqX21dmuHntHtcvzbD5JjRWOEE2ZVkZZK6u0GsoHClZFp2vsN138sjqNuCwurHNuoitf4CWOsjsPxWOUn+Qh2aBqvSZgHeVwGIA/3O/gaA3yIrHT3RtY0DwP4STuewvp9dUTYhhnczttOXfd3lZS5/rBRYAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/0c8985426a86d22cc5bd019e68c03210/07788/thumbnail-coding-test.png","srcSet":"/static/0c8985426a86d22cc5bd019e68c03210/b82c5/thumbnail-coding-test.png 336w,\n/static/0c8985426a86d22cc5bd019e68c03210/9de5e/thumbnail-coding-test.png 671w,\n/static/0c8985426a86d22cc5bd019e68c03210/07788/thumbnail-coding-test.png 1342w","sizes":"(min-width: 1342px) 1342px, 100vw"},"sources":[{"srcSet":"/static/0c8985426a86d22cc5bd019e68c03210/7a2cc/thumbnail-coding-test.webp 336w,\n/static/0c8985426a86d22cc5bd019e68c03210/e8438/thumbnail-coding-test.webp 671w,\n/static/0c8985426a86d22cc5bd019e68c03210/f0ee1/thumbnail-coding-test.webp 1342w","type":"image/webp","sizes":"(min-width: 1342px) 1342px, 100vw"}]},"width":1342,"height":806}},"publicURL":"/static/0c8985426a86d22cc5bd019e68c03210/thumbnail-coding-test.png"}}}}]}},"pageContext":{"slug":"/CI_Part4_Ch15/"}},"staticQueryHashes":[]}